---
title: Java虚拟机笔记
date: 2018-04-16 15:52:18
tags: 
	- Java虚拟机
---

# 内存模型

## 程序计数器

### 什么是程序计数器？

当前线程正在执行字节码的行号指示器，就是说记录着当前线程正在执行的是哪一条字节码指令的地址。

### 作用

1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制(顺序执行，选择，循环等等)
2. 如果是在多线程的情形下，程序计数器会记录下当前线程执行到什么位置，当线程切换回来的时候就可以知道之前的线程执行到什么地方了。

### 特点

1. 线程私有，也就意味着生命周期随着线程创建而创建，死亡而死亡
2. 不会出现OOM的内存区域

<!--more-->

## Java虚拟机栈

### 什么是Java虚拟机栈？

描述Java方法执行过程的内存模型,

### 作用

当一个方法即将运行的时候，Java虚拟机就会在Java虚拟机栈上开辟一块"栈帧",里面包含着局部变量表、操作数栈、动态链接、方法出口等信息。

### 特点

1. 线程私有，也就意味着生命周期随着线程创建而创建，死亡而死亡
2. 局部变量表的大小在编译的时候就被确定下了，但是局部变量表的创建是在方法执行的时候
3. 会出现栈溢出(线程请求栈深度超过)和内存溢出情况

> StackOverFlowError表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多。而OutOfMemoryError是指当线程申请栈时发现栈已经满了，而且内存也全都用光了。

## 本地方法栈

### 什么是本地方法栈？

 本地方法运行的内存模型

### 作用

本地方法在被执行的时候，会在本地方法栈中创建一个栈帧，用于存放本地方法的局部变量表、操作数栈、动态链接、出口信息等

### 特点

1. 线程私有，随着线程生与死
2. 会出现内存溢出和栈溢出

## 堆

### 什么是堆？

存放对象的内存空间，几乎所有对象都存放在堆中

### 特点

1. 线程共享
2. 在虚拟机启动的时候创建
3. 垃圾回收的主要场所
4. 可以分为新生代、老年代
5. 堆的大小可以固定也可以扩展，当堆满且不可以扩展的时候，就会出现内存溢出的情况

## 方法区

### 什么是方法区?

方法区是堆的一个逻辑部分，存放着已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等

### 特点

1. 线程共享
2. 老年代主要区域
3. 垃圾回收效率低，对方法区回收的主要目标是常量池的回收和类型的卸载
4. 允许固定大小、也可以不固定还可以允许不垃圾回收

### 运行时常量池

1. 常量储存在运行时常量池中
2. 一般在一个类中通过public static final 来声明一个长亮，这个类被编译之后会生成一个Class文件，类中的所有信息都被储存在这个class文件中
3. 当上面的这个类被虚拟机加载之后，class文件中的常量就会存放在方法区中的运行时常量池中，而且在运行期间可以向常量池中添加新的常量。String类中的intern()方法就能在运行期间向常量池中添加字符串常量
4. 在运行时常量池中的某些敞亮没有被对象引用，同时也没有被变量引用，那么就会被垃圾收集器回收

# Java对象创建的过程

## 对象的创建过程

当虚拟机遇到一条含有new指令的时候，会进行一系列对象创建的过程

1. 检查**常量池**中是否含有即将要创建的这个对象的类的符号引用
    - 如果常量池中没有这个类的符号引用，说明这个类还没有被定义，报ClassNotFoundException
    - 有的话进行第二步操作
2. 接着检查这个符号引用代表的类有没有被JVM加载
    - 没有加载的话，就找到该类的class文件，并加载到方法区
    - 加载了的话，就准备为对象分配内存
3. 根据方法区中该类的信息确定该类需要的内存大小
4. 从堆中划分一块对应大小的内存空间分配给新的对象。分配堆中内存有两种方式
    - 指针碰撞：如果JVM的垃圾收集器采用的是复制算法或者标记-整理算法，那么堆中的空闲内存会是一片完整的区域，并且空闲内存和已使用的内存之间有一个指针标记。当一个对象分配内存的时候，只需要移动指针就可以了。这种在完整空闲内存区域通过移动指针来分配内存区域的方法就被称之为"指针碰撞"
    - 空闲列表：如果JVM的垃圾收集器采用的是标记-清除算法，那么在堆中的内存已使用区域和空闲区域就会相互交错，所有这个时候就会需要一个空闲列表来记录堆中那些区域是空闲的。所以创建对象的时候会根据这个空闲列表来进行分配内存
5. 为对象中的成员变量进行赋初值
6. 设置对象头中的消息
7. 调用对象的构造函数进行初始化

## 访问对象的过程

1. 句柄访问方式：堆中有一块叫做"句柄池"的内存空间，用来存放所有对象的地址和所有对象所属类的类信息。引用类型的变量存放的是该变量在句柄池中的地址。访问对象的时候，首先需要通过引用类型的变量找到该对象的句柄，然后根据句柄中对象的地址再访问对象。
2. 直接指针访问方式：引用类型的变量直接存放对象的地址，不需要句柄池，通过引用能够直接访问对象。*但是对象所在的内存空间中需要额外的策略存储对象所属的类信息的地址*

# Java对象内存分配

Java的内存管理主要是针对于对内存中的对象的分配和回收

## 对象优先在Eden区中分配

1. 堆中内存分为新生代和老年代
2. 新生代(复制算法)进一步分为Eden+ survior from + survior to
3. 每次创建对象的时候，首先在Eden区进行分配。Eden区满则在 Survior from中分配，如果Survior from也满了，则启动分配担保，将这两区域的对象转移到老年代，重新再Eden区中分配新的对象

## 大对象直接进入老年代

大对象：占用大量连续存储空间的对象

## 生命周期较长的对象进入老年代

## 相同年龄的对象内存超过Survior内存一半的对象进入老年代

## Minor GC
当Eden内存区域满了的时候，将Eden区域的内存碎片和Survior from区域的转移到Survior to 中

## Full GC
老年代的内存区域满了之后，全部的内存区域都进行GC

# 垃圾收集算法

 ## 判断哪些对象需要回收
 
 1. 引用计数法：每个对象都有一个计数器，当这个对象被一个变量或者另一个对象引用的时候，计数器加一；若该引用失效便计数器减一。当计数器为0的时候，就认为该对象是无效对象(无法解决循环引用的问题)
 2. 可达性分析：所有和GC Roots直接或间接关联的对象都是有效对象，和GC Roots没有关联的对象就是无效对象

## 回收无效对象的过程

1. 判断对象是否覆盖了finalize()方法
    - 覆盖，且该方法的finalize()方法没有执行，就会将finalize()方法扔到F-Queue队列中
    - 没有覆盖，直接释放对象内存
2. 执行F-Queue队列中的finalize（）方法。如果出现耗时操作就会直接停止执行，将该对象清除
3. 对象重生或者死亡，在执行finalize的过程中，若有引用则重生，没有则清除

## 垃圾收集算法

1. 标记-清除算法
2. 复制算法
3. 标记-整理算法
4. 分代收集算法

## Java引用的种类

1. 强引用
我们平时所使用的引用就是强引用。 A a = new A(); 也就是通过关键字new创建的对象所关联的引用就是强引用。 只要强引用存在，该对象永远也不会被回收。
2. 软引用
只有当堆即将发生OOM异常时，JVM才会回收软引用所指向的对象。 软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。
3. 弱引用
只要垃圾收集器运行，软引用所指向的对象就会被回收。 弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。
4. 虚引用
虚引用也叫幽灵引用，它和没有引用没有区别，无法通过虚引用访问对象的任何属性或函数。 一个对象关联虚引用唯一的作用就是在该对象被垃圾收集器回收之前会受到一条系统通知。 虚引用通过PhantomReference类来实现。 

# class文件结构

# Java类加载的过程

1. 类从加载内存到卸载内存一共会经历7个阶段:加载-->验证-->准备-->解析-->初始化-->使用-->卸载
2. 类加载经历的阶段：加载-->验证-->准备-->解析-->初始化
3. 类加载是在程序的运行期完成的

## 类加载过程中的初始化时机

 1. 在运行过程中遇到以下字节码指令时，如果类没有初始化，那就要进行初始化：new getstatic putstatic invokestatic
    - 通过new创建对象
    - 读取一个类的静态成员变量（不包含final修饰）
    - 设置一个类的静态成员变量（不包含final修饰）
    - 调用一个类的静态成员函数
2. 进行反射调用的时候，没有类初始化就，那就需要初始化
3. 初始化一个类的时候，如果父类没有初始化就先初始化父类，再初始化本类
4. 虚拟机启动时，虚拟机先初始化主类

## 准备

准备阶段完成两件事情
1. 为已经在方法区中的类中的静态成员变量分配内存，类的静态成员变量也存储在方法区中
2. 为静态成员变量设置初始值，初始值为0，false，null等

例：
```
public static String name = "柴毛毛";
```

在准备阶段，JVM会在方法区中为name分配内存空间，并赋上初始值null。 给name赋上"柴毛毛"是在初始化阶段完成的。

例：
```
public static final String name = "柴毛毛";
```

被final修饰的常量如果有初始值，那么在编译阶段就会将初始值存入constantValue属性中，在准备阶段就将constantValue的值赋给该字段。